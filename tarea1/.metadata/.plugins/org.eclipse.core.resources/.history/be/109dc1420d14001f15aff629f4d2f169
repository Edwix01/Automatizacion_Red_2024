//
// Copyright (C) 2006-2011 Christoph Sommer <christoph.sommer@uibk.ac.at>
//
// Documentation for these modules is at http://veins.car2x.org/
//
// SPDX-License-Identifier: GPL-2.0-or-later
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

#include "veins/modules/application/traci/TraCIDemo11p.h"

#include "veins/modules/application/traci/TraCIDemo11pMessage_m.h"

using namespace veins;

Define_Module(veins::TraCIDemo11p);

void TraCIDemo11p::initialize(int stage)
{
    DemoBaseApplLayer::initialize(stage);
    if (stage == 0) {
        sentMessage = false;
        lastDroveAt = simTime();
        currentSubscribedServiceId = -1;
    }
}

void TraCIDemo11p::onWSA(DemoServiceAdvertisment* wsa)
{
    if (currentSubscribedServiceId == -1) {
        mac->changeServiceChannel(static_cast<Channel>(wsa->getTargetChannel()));
        currentSubscribedServiceId = wsa->getPsid();
        if (currentOfferedServiceId != wsa->getPsid()) {
            stopService();
            startService(static_cast<Channel>(wsa->getTargetChannel()), wsa->getPsid(), "Mirrored Traffic Service");
        }
    }
}

void TraCIDemo11p::onWSM(BaseFrame1609_4* frame)
{
    static int count = 0;
    TraCIDemo11pMessage* wsm = check_and_cast<TraCIDemo11pMessage*>(frame);

    if (wsm-> getReroute() && mobility->getRoadId()[0] != ':'){
        findHost()->getDisplayString().setTagArg("i", 1, "green");
        if(mobility->getId() == 35 && count == 0){
            traciVehicle->changeRoute(wsm->getDemoData(), 9999); //Aqui ejecuta un cambio en la ruta
            std::string nuevaCalle = traciVehicle->getRoadId();
        }
        count++;
    }
    if (!sentMessage && count == 0) {
        sentMessage = true;
        wsm->setSenderAddress(myId);
        wsm->setSerial(1);
        scheduleAt(simTime() + 5 + uniform(0.01, 0.2), wsm->dup());
    }
}

void TraCIDemo11p::handleSelfMsg(cMessage* msg)
{
   if (TraCIDemo11pMessage* wsm = dynamic_cast<TraCIDemo11pMessage*>(msg)) {
        if (wsm->getSerial() == 2) {
            wsm->setReroute(true);
            std::cout << "ENVIAMOS BANDERA DE REROUTE = TRUE" << std::endl;
        }
        if (mobility->getId() != 17) {
            std::cout << "ID DEL NODO QUE REENVIA EL SMS: " << mobility->getId() << std::endl;
            sendDown(wsm->dup());
        }
        wsm->setSerial(wsm->getSerial() + 1);

        if (wsm->getSerial() >= 3) {
            std::cout << "SERVICIO OFF" << std::endl; //AQUI SE DICE Q CUANDO SEA EL MENSAJE SERIAL 3 SE PARE EL SERVICIO Y SI ES 2 NUNCA CAMBIA LA RUTA Y PARA AHI EL SERVICIO
            stopService();
            delete (wsm);
        }
        else {
            scheduleAt(simTime() + 5, wsm);
        }
    }
    else {
        DemoBaseApplLayer::handleSelfMsg(msg);
    }
}


#include <string>
double lastMessageTime = 0;

void TraCIDemo11p::handlePositionUpdate(cObject* obj)
{
    DemoBaseApplLayer::handlePositionUpdate(obj);
    static std::string stopRout = "";
    static int c = 0;
    const int monitoredVehicleId = 17;  // ID del vehículo deseado


    if (mobility->getId() == monitoredVehicleId && c == 0) {
        if (simTime() - lastDroveAt >= 5) {
            findHost()->getDisplayString().setTagArg("i", 1, "red");
            TraCIDemo11pMessage* wsm = new TraCIDemo11pMessage();
            populateWSM(wsm);
            wsm->setSpeed(mobility->getVehicleCommandInterface()->getSpeed());
            stopRout= "400008031#3"; //ID POR EL Q NO VA A PASAR EL VEHICULO
            wsm->setDemoData(stopRout.c_str());
            if (dataOnSch) {
                startService(Channel::sch2, 42, "Traffic Information Service");
                scheduleAt(computeAsynchronousSendingTime(1, ChannelType::service), wsm);
            }
            else {
                sendDown(wsm);
            }
            c++;
        }
    }
    else if (mobility->getId() != 17) {
        lastDroveAt = simTime();
    }
}

/*void TraCIDemo11p::handlePositionUpdate(cObject* obj)
{
    DemoBaseApplLayer::handlePositionUpdate(obj);
    static int contador = 0;
    //std::cout << "Node ID: " << mobility->getId() << std::endl;
    static std::string stopRout = "";
    // Verifica si el nodo es el "17" y si han pasado 5 segundos desde la última vez.

    if (mobility->getId() == 17 && (simTime().dbl() - lastMessageTime >= 5) && contador == 0){


        lastMessageTime = simTime().dbl();

        //std::cout << "Información específica para el nodo 17:" << std::endl;
        //std::cout << "Node ID: " << mobility->getId() << std::endl;
        //std::cout << "Aceleración: " << mobility->getVehicleCommandInterface()->getAcceleration() << std::endl;
        //std::cout << "Emisiones de CO2: " << mobility->getVehicleCommandInterface()->getCO2Emissions() << std::endl;
        //std::cout << "ID de carretera: " << mobility->getRoadId() << std::endl;
        //std::cout << "Velocidad: " << mobility->getSpeed() << std::endl;

        TraCIDemo11pMessage* wsm = new TraCIDemo11pMessage();
        populateWSM(wsm);
        wsm->setSpeed(mobility->getVehicleCommandInterface()->getSpeed());
        stopRout= "400008031#3"; //ID POR EL Q NO VA A PASAR EL VEHICULO
        wsm->setDemoData(stopRout.c_str());

        //wsm->setDemoData(mobility->getRoadId().c_str());
        std::cout << "Entra: envio mensaje:"<< stopRout.c_str() << std::endl;

        if (dataOnSch) {
            startService(Channel::sch2, 42, "Traffic Information Service");
            scheduleAt(computeAsynchronousSendingTime(1, ChannelType::service), wsm);
        } else {
            sendDown(wsm);
        }
        contador++;
    }
    // Si el identificador no es "17", actualiza el tiempo del último movimiento.
    else if (mobility->getId() != 17) {
        lastDroveAt = simTime();
    }
}*/
